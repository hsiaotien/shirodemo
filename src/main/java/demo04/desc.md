
# md5散列

我们如果知道md5，我们就会知道md5是不可逆的，但是如果设置了一些安全性比较低的密码：
111111...即时是不可逆的，但还是可以通过暴力算法来得到md5对应的明文...


> 建议对md5进行散列时加salt（盐），进行加密相当 于对原始密码+盐进行散列。\
>
> 正常使用时散列方法：
>
> 在程序中对原始密码+盐进行散列，将散列值存储到数据库中，并且还要将盐也要存储在数据库中。


# 自定义realm支持md5


- 用户认证和用户授权是Shiro的基础，用户认证其实上就是登陆操作、用户授权实际上就是对资源拦截的操作。
- 权限管理的模型一般我们都将资源放在权限表中进行管理起来。
- 我们可以基于角色拦截，也可以基于资源拦截。要是基于角色拦截的话，那么如果角色的权限发生变化了，那就需要修改代码了。推荐使用基于资源进行拦截
- 这次URL拦截，我们使用一个JavaBean来封装所有的认证信息。当用户登陆了之后，我们就把用户对菜单栏的访问、对资源的访问权限都封装到该JavaBean中
- 当使用拦截器进行用户认证的时候，我们只要判断Session域有没有JavaBen对象即可了。
- 当时候拦截器进行用户授权的时候，我们要判断JavaBean中的权限是否能够访问该资源。
- 以前URL拦截的方式需要把所有的URL都在数据库进行管理。非常麻烦，不易维护。
- 我们希望Shiro去认证的时候是通过realm去数据库查询数据的。而我们reaml默认是查询配置文件的数据的。
- 因此，我们需要自定义reaml，使得它是去数据库查询数据。只要继承AuthorizingRealm类就行了。
- 当然了，自定义后的reaml也需要在配置文件中写上我们的自定义reaml的位置的。
- 散列算法就是为了让密码不被别人给破解。我们可对原始的密码加盐再进行散列，这就加大了破解的难度了。
- 自定义的reaml也是支持散列算法的，相同的，还是需要我们在配置文件中配置一下就好了。